<html>

<head>
    <meta charset="utf-8">
    <title>Battista</title>
    <link href='http://fonts.googleapis.com/css?family=Buenard' rel='stylesheet' type='text/css'>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body onload="main()">
    <canvas id="game"></canvas>
    <div id="game"></div>
    <!-- TODO: Figure out how to link to this. -->
    <!--<p><a href="getting-started.html" target="_blank">How to Play</a></p>-->
</body>
<script type="application/javascript">
    let size = {x: 10, y: 10};
    let roomSize = 40;
    let doorProbability = 0.1;
    let cells = []
    for (let y = 0; y < size.y; ++y){
        cells[y] = [];
    }

    let rooms = []
    let roomSettings = [
        "#339933",
        "#3366cc",
        "#ff5050", 
        "#cc9900"
    ]
    
    let canvas = document.getElementById("game");
    var ctx = canvas.getContext('2d')
    ctx.imageSmoothingEnabled = false;
    canvas.height = size.y * (roomSize + 2);
    canvas.width = size.x * (roomSize + 2)

    let edgeTypes = {
        DOOR: "door",
        PASSAGE: "passage",
        WALL: "wall",
    }

    let mazeDirection = {
        NORTH: "north",
        EAST: "east",
        SOUTH: "south",
        WEST: "west"
    }

    function getOppositeDirection(direction){
        if (direction == mazeDirection.NORTH){
            return mazeDirection.SOUTH;
        } else if (direction == mazeDirection.EAST) {
            return mazeDirection.WEST;
        } else if (direction == mazeDirection.SOUTH) {
            return mazeDirection.NORTH;
        } else if (direction == mazeDirection.WEST) {
            return mazeDirection.EAST;
        }
    }

    let mazeAdjustments = {
        "north": {x: 0, y: -1},
        "east": {x: 1, y: 0},
        "south": {x: 0, y: 1},
        "west": {x: -1, y: 0}
    }

    async function main(){
        await generateMaze()
        console.log(cells[0].map(x => x.edges.length));
    }


    async function generateMaze(timestampe){
        let sleep = ms => {return new Promise(resolve => setTimeout(resolve, ms))};
        let coords = randomCoordinates();
        console.log(coords);

        let activeCells = [];
        doFirstGenerationStep(activeCells);
        let x = 0;
        while (activeCells.length > 0){
            doNextGenerationStep(activeCells);
            drawCells();
            await sleep(0.0);
        }
        drawCells();
    };

    function doFirstGenerationStep(activeCells){
        let newCell = createCell(randomCoordinates())
        let newRoom = createRoom(-1);
        addCellToRoom(newCell, newRoom);
        activeCells.push(newCell)
    }

    function doNextGenerationStep(activeCells){
        let index = activeCells.length - 1;
        let currentCell = activeCells[index];
        if (cellIsFullyInitialized(currentCell)) {
            activeCells.splice(index, 1);
            return;
        }
        let direction = randomUninitializedDirection(currentCell);
        let newCoordinates = addCoords(currentCell, mazeAdjustments[direction]);
        if (containsCoordinates(newCoordinates)) {
            let neighbor = getCell(newCoordinates);
            if (neighbor == null){
                neighbor = createCell(newCoordinates);
                createPassage(currentCell, neighbor, direction);
                activeCells.push(neighbor);
            } else if (neighbor.room == currentCell.room){
                createPassageInSameRoom(currentCell, neighbor, direction);
            } else {
                createWall(currentCell, neighbor, direction);
            }
        } else {
            createWall(currentCell, null, direction);
        }

    }

    function addCoords(coordsA, coordsB){
        return {
            x: coordsA.x + coordsB.x, 
            y: coordsA.y + coordsB.y
        }
    }

    function randomCoordinates(){
        return {
            x: Math.floor(Math.random() * size.x), 
            y:Math.floor(Math.random() * size.y)
        }
    }

    function randomUninitializedDirection(cell){
        // Ranom number from 0 to the number of uninitialized edges
        let usedDirections = cell.edges.map(x => x.direction)
        let unusedDirections = Object.values(mazeDirection).filter(x => !usedDirections.includes(x));
        return unusedDirections[Math.floor(Math.random() * unusedDirections.length)]
    }


    function containsCoordinates(coords){
        return coords.x >= 0 && coords.x < size.x && coords.y >= 0 && coords.y < size.y;
    }

    function createCell(coords){
        let cell = {
            x: coords.x,
            y: coords.y,
            edges: [],
            room: undefined,
        }
        cells[coords.y][coords.x] = cell;
        return cell
    }

    function createPassage(cellA, cellB, direction){
        let type = Math.random() < doorProbability ? edgeTypes.DOOR : edgeTypes.PASSAGE;
        let passage = {
            type: type,
            cell: cellA,
            otherCell: cellB,
            direction: direction
        }
        cellA.edges.push(passage);

        if (passage.type == edgeTypes.DOOR) {
            let newRoom = createRoom(cellA.room.settingsIndex)
            addCellToRoom(cellB, newRoom)
        } else {
            addCellToRoom(cellB, cellA.room);
        }
        
        let oppositePassage = {
            type: type,
            cell: cellB,
            otherCell: cellA,
            direction: getOppositeDirection(direction),
        }
        cellB.edges.push(oppositePassage)
    }

    function createPassageInSameRoom(cellA, cellB, direction){
        let passage = {
            type: edgeTypes.PASSAGE,
            cell: cellA,
            otherCell: cellB,
            direction: direction
        }
        cellA.edges.push(passage);
        
        let oppositePassage = {
            type: edgeTypes.PASSAGE,
            cell: cellB,
            otherCell: cellA,
            direction: getOppositeDirection(direction),
        }
        cellB.edges.push(oppositePassage)
    }

    function createWall(cellA, cellB, direction){
        let wall = {
            type: edgeTypes.WALL,
            cell: cellA,
            otherCell: cellB,
            direction: direction
        }
        cellA.edges.push(wall);
        
        if (cellB != null) {
            let oppositeWall = {
                type: edgeTypes.WALL,
                cell: cellB,
                otherCell: cellA,
                direction: getOppositeDirection(direction),
            }
            cellB.edges.push(oppositeWall)
        }
    }

    function createRoom(indexToExclude){
        let settingsIndex = Math.floor(Math.random() * roomSettings.length);
        if (settingsIndex == indexToExclude){
            settingsIndex = (settingsIndex + 1) % roomSettings.length;
        }
        let room = {
            settingsIndex: settingsIndex,
            cells: []
        }
        console.log(room);
        rooms.push(room);
        return room;
    }

    function addCellToRoom(cell, room){
        cell.room = room;
        room.cells.push(cell);
    }

    function getCell(coords){
        return cells[coords.y][coords.x];
    }

    function cellIsFullyInitialized(cell){
        return cell.edges.length == Object.keys(mazeDirection).length;
    }

    function drawCells(){
        ctx.clearRect(0, 0, size.x, size.y);
        for (let y = 0; y < size.y; ++y){
            for (let x = 0; x < size.x; ++x) {
                if (cells[y][x] != null){
                    drawCell(cells[y][x]);
                }
            }
        }
    }

    function drawCell(cell) {

        let leftX = 1 + (cell.x * roomSize + (cell.x * 2));
        let rightX = 1 + (cell.x * roomSize + (cell.x * 2)) + roomSize;
        let topY = 1 + (cell.y * (roomSize) + (cell.y * 2));
        let bottomY = 1 + (cell.y * (roomSize) + (cell.y * 2)) + roomSize;

        ctx.beginPath();
        let color = roomSettings[cell.room.settingsIndex];
        ctx.fillStyle = color;
        ctx.fillRect(
            leftX,
            topY,
            roomSize,
            roomSize
        );
        ctx.stroke();

        for (let i = 0; i < cell.edges.length; ++i) {
            let edge = cell.edges[i]
            ctx.beginPath();
            if (edge.type == edgeTypes.PASSAGE){
                let buffer = 0;
                ctx.strokeStyle = roomSettings[cell.room.settingsIndex];
                if (edge.direction == mazeDirection.NORTH) {
                    ctx.moveTo(leftX - buffer, topY);
                    ctx.lineTo(rightX + buffer, topY);
                } else if (edge.direction == mazeDirection.EAST) {
                    ctx.moveTo(rightX, topY - buffer);
                    ctx.lineTo(rightX, bottomY + buffer);
                } else if (edge.direction == mazeDirection.SOUTH) {
                    ctx.moveTo(rightX + buffer, bottomY);
                    ctx.lineTo(leftX - buffer, bottomY);
                } else if (edge.direction == mazeDirection.WEST) {
                    ctx.moveTo(leftX, bottomY + buffer);
                    ctx.lineTo(leftX, topY - buffer);
                }
            }
            ctx.stroke();
        }

        for (let i = 0; i < cell.edges.length; ++i) {
            ctx.beginPath()
            let edge = cell.edges[i]
            if (edge.type == edgeTypes.WALL) {
                ctx.strokeStyle = "grey";
                let buffer = 3
                ctx.lineWidth=2;
                if (edge.direction == mazeDirection.NORTH) {
                    ctx.moveTo(leftX - buffer, topY);
                    ctx.lineTo(rightX + buffer, topY);
                } else if (edge.direction == mazeDirection.EAST) {
                    ctx.moveTo(rightX, topY - buffer);
                    ctx.lineTo(rightX, bottomY + buffer);
                } else if (edge.direction == mazeDirection.SOUTH) {
                    ctx.moveTo(rightX + buffer, bottomY);
                    ctx.lineTo(leftX - buffer, bottomY);
                } else if (edge.direction == mazeDirection.WEST) {
                    ctx.moveTo(leftX, bottomY + buffer);
                    ctx.lineTo(leftX, topY - buffer);
                }
            }
            ctx.stroke();
        }
        
        for (let i = 0; i < cell.edges.length; ++i) {
            ctx.beginPath()
            let edge = cell.edges[i]
            if (edge.type == edgeTypes.DOOR) {
                ctx.strokeStyle = "black";
                let buffer = 3
                ctx.lineWidth=2;
                if (edge.direction == mazeDirection.NORTH) {
                    ctx.moveTo(leftX - buffer, topY);
                    ctx.lineTo(rightX + buffer, topY);
                } else if (edge.direction == mazeDirection.EAST) {
                    ctx.moveTo(rightX, topY - buffer);
                    ctx.lineTo(rightX, bottomY + buffer);
                } else if (edge.direction == mazeDirection.SOUTH) {
                    ctx.moveTo(rightX + buffer, bottomY);
                    ctx.lineTo(leftX - buffer, bottomY);
                } else if (edge.direction == mazeDirection.WEST) {
                    ctx.moveTo(leftX, bottomY + buffer);
                    ctx.lineTo(leftX, topY - buffer);
                }
            }
            ctx.stroke();
        }

    }
</script>

</html>