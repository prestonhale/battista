<html>

<head>
    <meta charset="utf-8">
    <title>Battista</title>
    <link href='http://fonts.googleapis.com/css?family=Buenard' rel='stylesheet' type='text/css'>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body onload="main()">
    <canvas id="game"></canvas>
    <div id="game"></div>
    <!-- TODO: Figure out how to link to this. -->
    <!--<p><a href="getting-started.html" target="_blank">How to Play</a></p>-->
</body>
<script type="application/javascript">
    let size = {x: 10, y: 10};
    let roomSize = 40;
    let doorProbability = 0.1;
    let cells = []
    for (let y = 0; y < size.y; ++y){
        cells[y] = [];
    }

    let rooms = []
    let roomSettings = [
        "#339933",
        "#3366cc",
        "#ff5050", 
        "#cc9900"
    ]
    
    let canvas = document.getElementById("game");
    var ctx = canvas.getContext('2d')
    ctx.imageSmoothingEnabled = false;
    canvas.height = size.y * (roomSize + 2);
    canvas.width = size.x * (roomSize + 2)

    let edgeTypes = {
        DOOR: "door",
        PASSAGE: "passage",
        WALL: "wall",
    }

    let mazeDirection = {
        NORTH: "north",
        EAST: "east",
        SOUTH: "south",
        WEST: "west"
    }

    let tiles = {
        MUSHROOM_FOREST: "mushroom forest",
        GIANT_MUSHROOM: "giant mushroom",
        SWAMP: "swamp",
    }

    let tileColors = new Map();
    tileColors.set(tiles.MUSHROOM_FOREST, "FireBrick");
    tileColors.set(tiles.GIANT_MUSHROOM, "DarkRed");
    tileColors.set(tiles.SWAMP, "DarkGreen");
    tileColors.set(tiles.HOUSE, "Grey");

    let locations = new Map();
    // TODO: Try expressing these as a simpler 2d array
    locations.set("Giant Mushroom", {
        positions: [
            {x: 0, y: 0, tile: tiles.GIANT_MUSHROOM},
        ]
    })
    locations.set("Mushroom Forest", {
        positions: [
            {x: 0, y: 0, tile: tiles.MUSHROOM_FOREST},
            {x: 1, y: 0, tile: tiles.MUSHROOM_FOREST},
            {x: 2, y: 0, tile: tiles.MUSHROOM_FOREST},
            {x: 0, y: 1, tile: tiles.MUSHROOM_FOREST},
            {x: 1, y: 1, tile: tiles.GIANT_MUSHROOM},
            {x: 1, y: 2, tile: tiles.MUSHROOM_FOREST},
        ]
    })
    locations.set("Swamp", {
        positions: [
            {x: 0, y: 0, tile: tiles.SWAMP},
            {x: 1, y: 0, tile: tiles.SWAMP},
            {x: 2, y: 0, tile: tiles.SWAMP},
            {x: 3, y: 0, tile: tiles.SWAMP},
            {x: 0, y: 1, tile: tiles.SWAMP},
            {x: 1, y: 1, tile: tiles.SWAMP},
            {x: 2, y: 1, tile: tiles.SWAMP},
            {x: 3, y: 1, tile: tiles.SWAMP},
            {x: 4, y: 1, tile: tiles.SWAMP},
        ]
    })

    // Walls represented as a "nibble" NESW 
    // aka 0101 (akaka 5) is a room with a wall in the E and W
    // aka 1000 (akaka 8) is a room with a wall only in the N
    // This whole thing saves space but is mostly to be clever 

    function getOppositeDirection(direction){
        if (direction == mazeDirection.NORTH){
            return mazeDirection.SOUTH;
        } else if (direction == mazeDirection.EAST) {
            return mazeDirection.WEST;
        } else if (direction == mazeDirection.SOUTH) {
            return mazeDirection.NORTH;
        } else if (direction == mazeDirection.WEST) {
            return mazeDirection.EAST;
        }
    }

    let mazeAdjustments = {
        "north": {x: 0, y: -1},
        "east": {x: 1, y: 0},
        "south": {x: 0, y: 1},
        "west": {x: -1, y: 0}
    }

    async function main(){
        await generateMaze()
    }


    async function generateMaze(){
        addLocation({x:0, y:0}, locations.get("Mushroom Forest"))
        addLocation({x:4, y:3}, locations.get("Giant Mushroom"))
        addLocation({x:5, y:2}, locations.get("Swamp"))
        drawCells();
    };

    function canPlaceLocation(position, location){

    }

    function addLocation(startPosition, location){
        for (let i = 0; i < location.positions.length; ++i){
            let position = {
                x: startPosition.x + location.positions[i].x,
                y: startPosition.y + location.positions[i].y
            }
            cells[position.y][position.x] = {
                x: position.x, 
                y: position.y, 
                tile: location.positions[i].tile
            };
        }
    }

    function hasWall(wallBit, direction){

    }

    function drawCells(){
        ctx.clearRect(0, 0, size.x, size.y);
        for (let y = 0; y < size.y; ++y){
            for (let x = 0; x < size.x; ++x) {
                if (cells[y][x] != null){
                    drawCell(cells[y][x]);
                }
            }
        }
    }

    function drawCell(cell) {

        let leftX = 1 + (cell.x * roomSize + (cell.x * 2));
        let rightX = 1 + (cell.x * roomSize + (cell.x * 2)) + roomSize;
        let topY = 1 + (cell.y * (roomSize) + (cell.y * 2));
        let bottomY = 1 + (cell.y * (roomSize) + (cell.y * 2)) + roomSize;

        ctx.beginPath();
        let color = tileColors.get(cell.tile);
        ctx.fillStyle = color;
        ctx.fillRect(
            leftX,
            topY,
            roomSize,
            roomSize
        );
        ctx.stroke();

        // for (let i = 0; i < cell.edges.length; ++i) {
        //     let edge = cell.edges[i]
        //     ctx.beginPath();
        //     if (edge.type == edgeTypes.PASSAGE){
        //         let buffer = 0;
        //         ctx.strokeStyle = roomSettings[cell.room.settingsIndex];
        //         if (edge.direction == mazeDirection.NORTH) {
        //             ctx.moveTo(leftX - buffer, topY);
        //             ctx.lineTo(rightX + buffer, topY);
        //         } else if (edge.direction == mazeDirection.EAST) {
        //             ctx.moveTo(rightX, topY - buffer);
        //             ctx.lineTo(rightX, bottomY + buffer);
        //         } else if (edge.direction == mazeDirection.SOUTH) {
        //             ctx.moveTo(rightX + buffer, bottomY);
        //             ctx.lineTo(leftX - buffer, bottomY);
        //         } else if (edge.direction == mazeDirection.WEST) {
        //             ctx.moveTo(leftX, bottomY + buffer);
        //             ctx.lineTo(leftX, topY - buffer);
        //         }
        //     }
        //     ctx.stroke();
        // }

        // for (let i = 0; i < cell.edges.length; ++i) {
        //     ctx.beginPath()
        //     let edge = cell.edges[i]
        //     if (edge.type == edgeTypes.WALL) {
        //         ctx.strokeStyle = "grey";
        //         let buffer = 3
        //         ctx.lineWidth=2;
        //         if (edge.direction == mazeDirection.NORTH) {
        //             ctx.moveTo(leftX - buffer, topY);
        //             ctx.lineTo(rightX + buffer, topY);
        //         } else if (edge.direction == mazeDirection.EAST) {
        //             ctx.moveTo(rightX, topY - buffer);
        //             ctx.lineTo(rightX, bottomY + buffer);
        //         } else if (edge.direction == mazeDirection.SOUTH) {
        //             ctx.moveTo(rightX + buffer, bottomY);
        //             ctx.lineTo(leftX - buffer, bottomY);
        //         } else if (edge.direction == mazeDirection.WEST) {
        //             ctx.moveTo(leftX, bottomY + buffer);
        //             ctx.lineTo(leftX, topY - buffer);
        //         }
        //     }
        //     ctx.stroke();
        // }
        
        // for (let i = 0; i < cell.edges.length; ++i) {
        //     ctx.beginPath()
        //     let edge = cell.edges[i]
        //     if (edge.type == edgeTypes.DOOR) {
        //         ctx.strokeStyle = "black";
        //         let buffer = 3
        //         ctx.lineWidth=2;
        //         if (edge.direction == mazeDirection.NORTH) {
        //             ctx.moveTo(leftX - buffer, topY);
        //             ctx.lineTo(rightX + buffer, topY);
        //         } else if (edge.direction == mazeDirection.EAST) {
        //             ctx.moveTo(rightX, topY - buffer);
        //             ctx.lineTo(rightX, bottomY + buffer);
        //         } else if (edge.direction == mazeDirection.SOUTH) {
        //             ctx.moveTo(rightX + buffer, bottomY);
        //             ctx.lineTo(leftX - buffer, bottomY);
        //         } else if (edge.direction == mazeDirection.WEST) {
        //             ctx.moveTo(leftX, bottomY + buffer);
        //             ctx.lineTo(leftX, topY - buffer);
        //         }
        //     }
        //     ctx.stroke();
        // }

    }
</script>

</html>