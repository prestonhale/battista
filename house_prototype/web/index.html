<html>
    <head>
        <meta charset="utf-8">
        <title>Battista</title>
        <link href='http://fonts.googleapis.com/css?family=Buenard' rel='stylesheet' type='text/css'>
        <style>
            canvas { border: 1px solid black; }
        </style>
    </head>
    <body onload="main()">
        <canvas id="game"></canvas>
        <div id="game"></div>
        <!-- TODO: Figure out how to link to this. -->
        <!--<p><a href="getting-started.html" target="_blank">How to Play</a></p>-->
    </body>
    <script type="application/javascript">
        let height = 21;
        let width = 21;

        // Player
        let playerStates = {
            CRAFTING: "crafting",
            EXPLORING: "exploring",
        }
        let playerState = playerStates.EXPLORING;
        let playerCraftingSelectionIndex = 0;

        // Crafting 
        let craftingSelections = [
            {
                displayName: "Food",
                costs: {
                    "green": 6
                }
            }, {
                displayName: "Torch",
                costs: {
                    "red": 3,
                    "blue": 3,
                    "green": 3
                }
            }, {
                displayName: "Blue Torch",
                costs: {
                    "blue": 9
                }
            }, {
                displayName: "Green Torch",
                costs: {
                    "green": 9
                }
            }, {
                displayName: "Red Torch",
                costs: {
                    "red": 9
                }
            }, {
                displayName: "Exit",
            }
        ];
        
        // Features
        let features = {
            exploredRoomsCostHalf: true,
            activelyGatherFromRooms: true,
            randomWallAlgo: true,
            mazeAlgo200: true,
            theming: true,
        }

        // Rooms
        let roomSize = 50;
        
        let roomColors = [
            "#bfbfbf",
            "#006600",
            "#800000",
            "#000099"
        ]

        let roomColorNames = {
            "#bfbfbf": "grey",
            "#006600": "green",
            "#800000": "red",
            "#000099": "blue"
        }

        let roomColorWeights = [
            0.85,
            0.05,
            0.05,
            0.05,
        ]

        // Themes
        let themes = {
            HOUSE: "house",
            FOREST: "forest",
            MUSHROOM: "mushroom",
            FLOODED: "flooded"
        }

        let themeToColor = new Map();
        themeToColor.set(themes.HOUSE, "#bfbfbf");
        themeToColor.set(themes.FOREST, "#006600");
        themeToColor.set(themes.MUSHROOM, "#800000");
        themeToColor.set(themes.FLOODED, "#000099");

        // Config
        let defaultTimeRemaining = 120;
        let defaultRoomResources = 3;
        let doorChance = 0.1;

        // Room details
        let discoveredRooms = [];
        let pinnedRooms = [];
        let pinnedWalls = [];
        let pinnedRoomThemes = [];
        let roomRemainingResources = [];
        /* 
        0 none
        1 n 
        2 e 
        3 s 
        4 w  
        5 ne
        6 es
        7 sw
        8 wn
        9 ns
        10 ew
        11 nes
        12 esw
        13 swn
        14 wne
        */

        let wallsWithoutNorth = [0, 2, 3, 4, 6, 7, 10, 12]
        let wallsWithoutEast =  [0, 1, 3, 4, 7, 8, 9, 13];
        let wallsWithoutSouth = [0, 1, 2, 4, 5, 8, 10, 14]
        let wallsWithoutWest = [0, 1, 2, 3, 5, 6, 9, 11]

        let wallsWithNorth = [1, 5, 8, 9, 11, 13, 14];
        let wallsWithEast = [2, 5, 6, 10, 11, 12, 14];
        let wallsWithSouth = [3, 6, 7, 9, 12, 13];
        let wallsWithWest = [4, 7, 8, 10, 12, 13];

        let openExitsToMaintain = 4;

        let roomWalls = [];
        let roomDoors = [];
        let roomThemes = [];

        let playerX = Math.floor(height/2);
        let playerY = Math.floor(width/2);
        let playerResourceTimeRemaining = defaultTimeRemaining;
        let playerResourceGreen = 10;
        let playerResourceRed = 10;
        let playerResourceBlue = 10;
        let playerResourceYellow = 0;
        let playerResourceFood = 0;
        let playerResourceTorch = 3;

        let startRoomIndex = getIndexFromCoords(playerX, playerY);
        discoveredRooms[startRoomIndex] = roomColors[0];
        pinnedRooms[startRoomIndex] = roomColors[0];
        roomWalls[startRoomIndex] = 0;
        roomThemes[startRoomIndex] = themes.HOUSE;

        let animating = false;

        document.addEventListener("keydown", keyHandler, false);

        function main(){
            console.log("Canvas initialized");
            canvas.height = height * (roomSize + 1);
            canvas.width = height * (roomSize + 1);
            render();
        }

        function keyHandler(e) {
            var handled = false;
            if (e.key !== undefined) {
                handled = true;

                // For maze debugging
                if (e.key == "?"){
                    walkMaze();
                }

                if (playerState == playerStates.CRAFTING){
                    if(e.key == "Enter" || e.key == " "){
                        craftSelection();
                    }
                    if(e.key == "Up" || e.key == "ArrowUp" || e.key == "w") {
                        handleCraftingMenuMovement("up");
                    }
                    if(e.key == "Down" || e.key == "ArrowDown" || e.key == "s") {
                        handleCraftingMenuMovement("down");
                    }
                    if (e.key == "c") {
                        console.log("crafting");
                        stopCrafting();
                    }
                } else {
                    if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d") {
                        handleMovement("right");
                    }
                    if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a") {
                        handleMovement("left");
                    }
                    if(e.key == "Up" || e.key == "ArrowUp" || e.key == "w") {
                        handleMovement("up")
                    }
                    if(e.key == "Down" || e.key == "ArrowDown" || e.key == "s") {
                        handleMovement("down");
                    }
                    if (e.key == "r") {
                        resetHouse();
                    }
                    if (e.key == "x") {
                        pinPath();
                    }
                    if (e.key == "c") {
                        startCrafting();
                    }
                    if (e.key == " "){
                        if (features.activelyGatherFromRooms){
                            gatherRoom();
                        }
                    }
                }

                if (playerResourceTimeRemaining < 0){
                    resetHouse();
                }
            }
            
            if (handled) {
                event.preventDefault();
            }

            render();
        }

        function walkMaze() {
            let directions = ["up", "down", "left", "right"];
            playerResourceTimeRemaining = 100000;
            for (let i = 0; i < 100; ++i){
                let direction = directions[Math.floor(Math.random() * directions.length)];
                handleMovement(direction);
            }
            render();
        }

        function resetHouse (){
            discoveredRooms = []
            playerX = Math.floor(width/2);
            playerY = Math.floor(width/2);
            discoveredRooms = [...pinnedRooms];

            if (features.randomWallAlgo) {
                roomWalls = [];
                roomWalls = [...pinnedWalls];
            }
            
            if (features.theming) {
                roomThemes = [];
                roomThemes = [...pinnedRoomThemes];
            }

            if (features.activelyGatherFromRooms){
                roomRemainingResources = [];
                for (let i = 0; i < discoveredRooms.length; ++i){
                    if (discoveredRooms[i] !== null && roomColorNames[discoveredRooms[i]] == "grey"){
                        roomRemainingResources[i] = 0;
                    } else if (discoveredRooms[i] !== null){
                        roomRemainingResources[i] = defaultRoomResources;
                    }
                }
            }

            if (features.mazeAlgo200){
                openExitsThisRun = openExitsSaved;
            }

            playerResourceTimeRemaining = defaultTimeRemaining;
            // resetAnimation();
        }

        function pinPath(){
            pinnedRooms = [...discoveredRooms];
            for (let i = 0; i < discoveredRooms.length; i ++) {
                if (pinnedRooms[i] == null){
                    pinnedRooms[i] = discoveredRooms[i];
                }
            }

            if (features.randomWallAlgo){
                for (let i = 0; i < pinnedRooms.length; ++i){
                    if (pinnedRooms[i] !== null){
                        pinnedWalls[i] = roomWalls[i];
                    }
                }
            }

            if (features.mazeAlgo200) {
                openExitsSaved = openExitsThisRun;
            }
            
            if (features.theming) {
                for (let i = 0; i < roomThemes.length; ++i){
                    if (roomThemes[i] !== null){
                        pinnedRoomThemes[i] = roomThemes[i];
                    }
                }
            }

            resetHouse();
        }

        function gatherRoom() {
            // Attempting to gather with no time left should just reset the house
            if (playerResourceTimeRemaining == 0){
                playerResourceTimeRemaining -= 1;
                return;
            }

            let roomIndex = getIndexFromCoords(playerX, playerY);
            let color = discoveredRooms[roomIndex];

            if (roomRemainingResources[roomIndex] <= 0){
                return;
            }

            if (roomColorNames[color] == "blue") {
                playerResourceBlue += 1;
                playerResourceTimeRemaining -= 1;
                roomRemainingResources[roomIndex] -= 1;
            } else if (roomColorNames[color] == "green") {
                playerResourceGreen += 1;
                playerResourceTimeRemaining -= 1;
                roomRemainingResources[roomIndex] -= 1;
            } else if (roomColorNames[color] == "red") {
                playerResourceRed += 1;
                playerResourceTimeRemaining -= 1;
                roomRemainingResources[roomIndex] -= 1;
            }

            return;
        }

        function getRandomRoomColor(){
            let randNum = Math.random(),
                s = 0,
                lastIndex = roomColorWeights.length - 1;
            
            for (var i = 0; i < lastIndex; ++i) {
                s += roomColorWeights[i];
                if (randNum < s) {
                    return roomColors[i];
                }
            }
            return roomColors[lastIndex];
        }

        function getRandomRoomWalls(direction, openExitsThisRun){
            let curWalls = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]

            if (features.randomWallAlgo){
                let roomIndex;
                roomIndex = getIndexFromCoords(playerX, playerY - 1);
                if (discoveredRooms[roomIndex]){
                    if (wallsWithSouth.includes(roomWalls[roomIndex])){
                        curWalls = curWalls.filter(value => wallsWithNorth.includes(value));
                    } else {
                        curWalls = curWalls.filter(value => wallsWithoutNorth.includes(value));
                    }
                }

                roomIndex = getIndexFromCoords(playerX + 1, playerY);
                if (discoveredRooms[roomIndex]){
                    if (wallsWithWest.includes(roomWalls[roomIndex])) {
                        curWalls = curWalls.filter(value => wallsWithEast.includes(value));
                    } else {
                        curWalls = curWalls.filter(value => wallsWithoutEast.includes(value));
                    }
                }
                
                roomIndex = getIndexFromCoords(playerX, playerY + 1);
                if (discoveredRooms[roomIndex]) {
                    if (wallsWithNorth.includes(roomWalls[roomIndex])){
                        curWalls = curWalls.filter(value => wallsWithSouth.includes(value));
                    } else {
                        curWalls = curWalls.filter(value => wallsWithoutSouth.includes(value));
                    }
                }
                
                roomIndex = getIndexFromCoords(playerX - 1, playerY);
                if (discoveredRooms[roomIndex]){
                    if (wallsWithEast.includes(roomWalls[roomIndex])){
                        curWalls = curWalls.filter(value => wallsWithWest.includes(value));
                    } else {
                        curWalls = curWalls.filter(value => wallsWithoutWest.includes(value));
                    }
                }
            }

            let withoutFilter;
            if (direction == "up"){ // Must not have S
                withoutFilter = wallsWithoutSouth;
            } else if (direction == "right"){ // Must not have W
                withoutFilter = wallsWithoutWest;
            } else if (direction == "down"){ // Must not have N
                withoutFilter = wallsWithoutNorth;
            } else if (direction == "left"){ // Must not have E
                withoutFilter = wallsWithoutEast;
            }
            curWalls = curWalls.filter(value => withoutFilter.includes(value));

            if (openExitsThisRun !== null && openExitsToMaintain - openExitsThisRun <= 1) {
                let nonDeadEndWallArrangements = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                curWalls.filter(value => nonDeadEndWallArrangements.includes(value))
            }

            return curWalls[Math.floor(Math.random() * curWalls.length)]
        }

        function getIndexFromCoords(x, y){
            return (width * y) + x;
        }

        function getCoordsFromIndex(i){
            let y;
            if (i < width) {
                y = 0
                x = i;
            } else {
                y = Math.floor(i/width)
                x = i % (width * y);
            }
            return [x, y];
        } 

        function handleMovement(direction){
            if (animating) {
                return;
            }
            
            let curRoomIndex = getIndexFromCoords(playerX, playerY);
            if (features.randomWallAlgo){
         

                if (direction == "up" && wallsWithNorth.includes(roomWalls[curRoomIndex])) {
                    return;
                } else if (direction == "right" && wallsWithEast.includes(roomWalls[curRoomIndex])) {
                    return;
                } else if (direction == "down" && wallsWithSouth.includes(roomWalls[curRoomIndex])) {
                    return;
                } else if (direction == "left" && wallsWithWest.includes(roomWalls[curRoomIndex])) {
                    return;
                }
            }
            
            // Move player
            if (direction == "up"){
                playerY -= 1;
            } else if (direction == "right"){
                playerX += 1;
            } else if (direction == "down"){
                playerY += 1;
            } else if (direction == "left"){
                playerX -= 1;
            }
            
            // Check if room is new
            let newRoomIndex = getIndexFromCoords(playerX, playerY);
            let color = discoveredRooms[newRoomIndex];
            let newRoom = color == null;
            if (newRoom) {

                if (features.mazeAlgo200){
                    getNewRoom200(direction)
                } else {
                    color = getRandomRoomColor();
                    discoveredRooms[newRoomIndex] = color;
                    
                    if (features.randomWallAlgo){
                        roomWalls[newRoomIndex] = getRandomRoomWalls(direction);
                    }

                    playerResourceTimeRemaining -= 2;
                    if (playerResourceTimeRemaining < 0 && playerResourceFood > 0){
                        --playerResourceFood;
                        playerResourceTimeRemaining = 0;
                    }
                    if (roomColorNames[color] == "grey"){
                        roomRemainingResources[newRoomIndex] = 0;
                    } else {
                        roomRemainingResources[newRoomIndex] = defaultRoomResources;
                    }
                }
            } else {
                if (features.exploredRoomsCostHalf) {
                    playerResourceTimeRemaining -= 1;
                } else {
                    playerResourceTimeRemaining -= 2;
                }
            }


            // Don't give resources automatically with actively gather on
            if (features.activelyGatherFromRooms != true){
                if (roomColorNames[color] == "blue") {
                    playerResourceBlue += 1;
                } else if (roomColorNames[color] == "green") {
                    playerResourceGreen += 1;
                } else if (roomColorNames[color] == "red") {
                    playerResourceRed += 1;
                }
            }

            console.log(`Player moved to: [${playerX}, ${playerY}]. Open Exits: ${openExitsThisRun}. Theme: ${roomThemes[newRoomIndex]}`);
        }

        function getCoordInDirection(x, y, direction){
            if (direction == "up") {
                return {x: x, y: y - 1};
            }
            if (direction == "down") {
                return {x: x, y: y + 1};
            }
            if (direction == "right") {
                return {x: x + 1, y: y};
            }
            if (direction == "left") {
                return {x: x - 1, y: y};
            }
        }

        function getOppositeDirection(direction){
            if (direction == "up") {
                return "down"
            }
            if (direction == "down") {
                return "up"
            }
            if (direction == "right") {
                return "left"
            }
            if (direction == "left") {
                return "right"
            }
        }

        let openExitsSaved = 4;
        let openExitsThisRun = 4;

        function getNewRoom200(direction){
            let newRoomIndex = getIndexFromCoords(playerX, playerY);
            let color;
            if (features.theming){
                let oppositeDirection = getOppositeDirection(direction);
                let prevCoord = getCoordInDirection(playerX, playerY, oppositeDirection);
                let previousRoomIndex = getIndexFromCoords(prevCoord.x, prevCoord.y);
                let theme;
                if (Math.random() < doorChance){ //Switch themes
                    console.log("DOOR!");
                    if (roomThemes[previousRoomIndex] !== themes.HOUSE){
                        theme = themes.HOUSE;
                    } else {
                        theme = getRandomTheme();
                        
                    }
                } else {
                    theme = roomThemes[previousRoomIndex];
                }
                roomThemes[newRoomIndex] = theme;
                color = themeToColor.get(theme);
            } else {
                color = getRandomRoomColor(); // aka getRandomNewTheme
            }
            discoveredRooms[newRoomIndex] = color;

            // How many NEW exits are created by a wall arrangement
            // Creating a room will REMOVE an open exit from the room you came from
            // for this reason wall types with 2 exits add 0 new exits they just maintain
            // the same number of open exits and rooms with 1 exit SUBTRACT 1 exit.
            let exitsByWallType = new Map([
                [0, 2],
                [1, 1],
                [2, 1],
                [3, 1],
                [4, 1],
                [5, 0],
                [6, 0],
                [7, 0],
                [8, 0],
                [9, 0],
                [10, 0],
                [11, -1],
                [12, -1],
                [13, -1],
                [14, -1]
            ])

            if (features.randomWallAlgo){
                let walls = getRandomRoomWalls(direction, openExitsThisRun);
                roomWalls[newRoomIndex] = walls
                openExitsThisRun += exitsByWallType.get(walls);
            }

            playerResourceTimeRemaining -= 2;
            if (playerResourceTimeRemaining < 0 && playerResourceFood > 0){
                --playerResourceFood;
                playerResourceTimeRemaining = 0;
            }
            if (roomColorNames[color] == "grey"){
                roomRemainingResources[newRoomIndex] = 0;
            } else {
                roomRemainingResources[newRoomIndex] = defaultRoomResources;
            }
        }

        function getRandomTheme(){
            let keys = Object.keys(themes);
            return themes[keys[((keys.length - 1) * Math.random() <<0) + 1]];
        }

        function craftSelection(){
            let craftedItem = craftingSelections[playerCraftingSelectionIndex];
            console.log(craftedItem);
            if (craftedItem.displayName == "Exit") {
                stopCrafting();
                return;
            }

            for (costColor in craftedItem.costs){
                console.log(`${costColor}: ${craftedItem.costs[costColor]}`);
                if (costColor == "red"){
                    if (playerResourceRed - craftedItem.costs[costColor] < 0){
                        return;
                    }
                    playerResourceRed = playerResourceRed - craftedItem.costs[costColor];
                } else if (costColor == "green"){
                    if (playerResourceGreen - craftedItem.costs[costColor] < 0){
                        return;
                    }
                    playerResourceGreen = playerResourceGreen - craftedItem.costs[costColor];
                } else if (costColor == "blue"){
                    if (playerResourceBlue - craftedItem.costs[costColor] < 0){
                        return;
                    }
                    playerResourceBlue = playerResourceBlue - craftedItem.costs[costColor];
                }
            }

            if (craftedItem.displayName.includes("Torch")){
                ++playerResourceTorch;
            } else if (craftedItem.displayName == "Food"){
                ++playerResourceFood;
            }
            
        }

        function startCrafting() {
            playerCraftingSelectionIndex = 0;
            playerState = playerStates.CRAFTING;
        }
        
        function stopCrafting() {
            playerState = playerStates.EXPLORING;
        }

        function handleCraftingMenuMovement(direction){
            if (direction == "up") {
                --playerCraftingSelectionIndex;
            }
            else if (direction == "down") {
                ++playerCraftingSelectionIndex;
            }
            playerCraftingSelectionIndex = (playerCraftingSelectionIndex + craftingSelections.length) % craftingSelections.length;
            console.log(playerCraftingSelectionIndex);
        }

        // Rendering
        const canvas = document.getElementById('game')
        var ctx = canvas.getContext('2d');

        function render(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < discoveredRooms.length; ++i) {
                let coords = getCoordsFromIndex(i);
                let x = coords[0];
                let y = coords[1];
                let color = discoveredRooms[i]
                if (color == null) {
                    continue;
                }
                drawRoom(x, y, i);
            }
            drawResources();
            drawPlayer();
            if (playerState == playerStates.CRAFTING){
                drawCraftingMenu(playerCraftingSelectionIndex);
            }
        }

        function drawPlayer(){
            let roomRightX = 1 + (playerX * roomSize + (playerX * 2));
            let roomTopY = 1 + (playerY * (roomSize) + (playerY * 2));
            ctx.fillRect(
                roomRightX + roomSize/3,
                roomTopY + roomSize/3,
                roomSize/3,
                roomSize/3,
            );
            ctx.stroke();
        }

        function drawRoom(x, y, index){
            let color = discoveredRooms[index];

            let leftX = 1 + (x * roomSize + (x * 2));
            let rightX = 1 + (x * roomSize + (x * 2)) + roomSize;
            let topY = 1 + (y * (roomSize) + (y * 2));
            let bottomY = 1 + (y * (roomSize) + (y * 2)) + roomSize;

            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.fillRect(
                leftX,
                topY,
                roomSize,
                roomSize
            );
            ctx.stroke();

            // Draw walls
            if (features.randomWallAlgo) {
                ctx.strokeStyle = "black"
                ctx.lineWidth = 1;
                ctx.beginPath()

                // Top Wall
                if ([1, 5, 8, 9, 11, 13, 14].includes(roomWalls[index])) {
                    if (roomWalls[index])
                    ctx.moveTo(leftX, topY);
                    ctx.lineTo(rightX, topY);
                }
                    
                // Right Wall
                if ([2, 5, 6, 10, 11, 12, 14].includes(roomWalls[index])) {
                    ctx.moveTo(rightX, topY);
                    ctx.lineTo(rightX, bottomY);
                }

                // Bottom Wall
                if ([3, 6, 7, 9, 12, 13].includes(roomWalls[index])) {
                    ctx.moveTo(rightX, bottomY);
                    ctx.lineTo(leftX, bottomY);
                }

                // Left Wall
                if ([4, 7, 8, 10, 12, 13].includes(roomWalls[index])) {
                    ctx.moveTo(leftX, topY);
                    ctx.lineTo(leftX, bottomY);
                }

                ctx.stroke();
            }

            // Draw dots for remaining resources
            if (features.activelyGatherFromRooms){
                // let topRightX = r + roomSize;
                // let topRightY = topLeftY;
                ctx.fillStyle = "black";
                for (let i = 1; i <= roomRemainingResources[index]; ++i){
                    let offset = roomSize/4 * i;
                    ctx.fillRect(
                        rightX - offset,
                        topY + 3,
                        roomSize/6,
                        roomSize/6
                    )
                }
            }
        }

        function drawCraftingMenu(){
            let topLeft = {
                x: canvas.width / 6,
                y: canvas.height / 8,
            }
            let fontHeight = 25;
            let font = "sans-serif";
            let lineBuffer = 10;

            let width = canvas.width / 3;
            let height = lineBuffer + (craftingSelections.length * (fontHeight + lineBuffer)) + lineBuffer;

            ctx.strokeStyle = "black";
            ctx.lineWidth = 4;
            ctx.strokeRect(
                topLeft.x,
                topLeft.y,
                width,
                height,
            );

            for (let i = 0; i < craftingSelections.length; ++i){
                let item = craftingSelections[i];
                ctx.font = fontHeight + "px " + font;
                ctx.fillStyle = "black";
                ctx.fillText(
                    item.displayName,
                    topLeft.x + (width / 10), 
                    topLeft.y + ((i + 1) * (fontHeight + lineBuffer)),
                );
                let j = 0;
                let offset = 50;
                for (colorName in item.costs){
                    ctx.font = (fontHeight * .75) + "px " + font
                    ctx.fillStyle = "black";
                    ctx.fillText(
                        item.costs[colorName] + "x",
                        topLeft.x + (width/2) + (j * offset),
                        topLeft.y + ((i + 1) * (fontHeight + lineBuffer)),
                    )
                    ctx.fillStyle = colorName;
                    ctx.fillRect(
                        topLeft.x + (width/2) + 20 + (j * offset),
                        topLeft.y + ((i + 1) * (fontHeight + lineBuffer)) - (fontHeight * 0.5),
                        fontHeight/2,
                        fontHeight/2,
                    )
                    ++j;
                }
                if (playerCraftingSelectionIndex == i){
                    ctx.fillStyle = "black";
                    ctx.fillRect(
                        topLeft.x + (width / 10) - 25, 
                        topLeft.y + ((i + 1) * (fontHeight + lineBuffer)) - (fontHeight / 2),
                        fontHeight / 3,
                        fontHeight / 3
                    )
                }
            }
        }

        function drawResources(){
            ctx.font = '25px sans-serif';
            ctx.fillText('Time Remaining: ' + playerResourceTimeRemaining, 4, roomSize);
            ctx.fillText('Red: ' + playerResourceRed, 4, roomSize * 2);
            ctx.fillText('Blue: ' + playerResourceBlue, 4, roomSize * 3);
            ctx.fillText('Green: ' + playerResourceGreen, 4, roomSize * 4);
            ctx.fillText('Yellow: ' + playerResourceYellow, 4, roomSize * 5);
            ctx.fillText('Food: ' + playerResourceFood, 4, roomSize * 6);
            ctx.fillText('Torches: ' + playerResourceTorch, 4, roomSize * 7);
        }

        async function resetAnimation(){
            let lightWave = "#0099ff";
            let darkWave = "#003399";

            animating = true;

            ctx.fillStyle = lightWave;
            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (pinnedRooms[getIndexFromCoords(x, y)] != null){
                        continue
                    }
                    ctx.fillRect(
                        1 + (x * roomSize + (x * 2)),
                        1 + (y * (roomSize) + (y * 2)),
                        roomSize,
                        roomSize
                    )
                }
            }

            await sleep(500);

            ctx.fillStyle = darkWave;
            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (pinnedRooms[getIndexFromCoords(x, y)] != null){
                        continue
                    }
                    ctx.fillRect(
                        1 + (x  * roomSize + (x * 2)),
                        1 + (y * (roomSize) + (y * 2)),
                        roomSize,
                        roomSize
                    )
                }
            }

            await sleep(500);

            ctx.fillStyle = lightWave;
            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (pinnedRooms[getIndexFromCoords(x, y)] != null){
                        continue
                    }
                    ctx.fillRect(
                        1 + (x * roomSize + (x * 2)),
                        1 + (y * (roomSize) + (y * 2)),
                        roomSize,
                        roomSize
                    )
                }
            }

            await sleep(500);

            animating = false;

            render();
        }


        function sleep(ms){
            return new Promise(resolve => setTimeout(resolve, ms));
        }

    </script>
</html>
    