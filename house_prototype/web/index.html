<html>
    <head>
        <meta charset="utf-8">
        <title>Battista</title>
        <link href='http://fonts.googleapis.com/css?family=Buenard' rel='stylesheet' type='text/css'>
        <style>
            canvas { border: 1px solid black; }
        </style>
    </head>
    <body onload="main()">
        <canvas id="game"></canvas>
        <div id="game"></div>
        <!-- TODO: Figure out how to link to this. -->
        <!--<p><a href="getting-started.html" target="_blank">How to Play</a></p>-->
    </body>
    <script type="application/javascript">
        let height = 21;
        let width = 21;
        
        // Features
        let features = {
            exploredRoomsCostHalf: true,
            activelyGatherFromRooms: true,
        }

        // Rooms
        let roomSize = 50;
        
        let roomColors = [
            "#bfbfbf",
            "#006600",
            "#800000",
            "#000099"
        ]

        let roomColorNames = {
            "#bfbfbf": "grey",
            "#006600": "green",
            "#800000": "red",
            "#000099": "blue"
        }

        let roomColorWeights = [
            0.85,
            0.05,
            0.05,
            0.05,
        ]

        // Config
        let defaultTimeRemaining = 12;
        let defaultRoomResources = 3;

        // Room details
        let discoveredRooms = [];
        let pinnedRooms = [];
        let roomRemainingResources = [];

        let playerX = Math.floor(height/2);
        let playerY = Math.floor(width/2);
        let playerResourceTimeRemaining = defaultTimeRemaining;
        let playerResourceGreen = 0;
        let playerResourceRed = 0;
        let playerResourceBlue = 0;
        let playerResourceYellow = 0;
        let playerResourceTorch = 3;

        discoveredRooms[getIndexFromCoords(playerX, playerY)] = roomColors[0];
        pinnedRooms[getIndexFromCoords(playerX, playerY)] = roomColors[0];

        let animating = false;

        document.addEventListener("keydown", keyHandler, false);

        function main(){
            console.log("Canvas initialized");
            canvas.height = height * (roomSize + 1);
            canvas.width = height * (roomSize + 1);
            render();
        }

        function keyHandler(e) {
            var handled = false;
            if (e.key !== undefined) {
                handled = true;
                if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d") {
                    handleMovement("right");
                }
                if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a") {
                    handleMovement("left");
                }
                if(e.key == "Up" || e.key == "ArrowUp" || e.key == "w") {
                    handleMovement("up")
                }
                if(e.key == "Down" || e.key == "ArrowDown" || e.key == "s") {
                    handleMovement("down");
                }
                if (e.key == "r") {
                    resetHouse();
                }
                if (e.key == "x") {
                    pinPath();
                }
                if (e.key == " "){
                    if (features.activelyGatherFromRooms){
                        gatherRoom();
                    }
                }

                if (playerResourceTimeRemaining < 0){
                    resetHouse();
                }
            }
            
            if (handled) {
                event.preventDefault();
            }

            render();
        }

        function resetHouse (){
            discoveredRooms = []
            playerX = Math.floor(width/2);
            playerY = Math.floor(width/2);
            discoveredRooms = [...pinnedRooms];

            if (features.activelyGatherFromRooms){
                roomRemainingResources = [];
                for (let i = 0; i < discoveredRooms.length; ++i){
                    if (discoveredRooms[i] !== null && roomColorNames[discoveredRooms[i]] == "grey"){
                        roomRemainingResources[i] = 0;
                    } else if (discoveredRooms[i] !== null){
                        roomRemainingResources[i] = defaultRoomResources;
                    }
                }
            }

            playerResourceTimeRemaining = defaultTimeRemaining;
            // resetAnimation();
        }

        function pinPath(){
            pinnedRooms = [...discoveredRooms];
            for (let i = 0; i < discoveredRooms.length; i ++) {
                if (pinnedRooms[i] == null){
                    pinnedRooms[i] = discoveredRooms[i];
                }
            }
            resetHouse();
        }

        function gatherRoom() {
            // Attempting to gather with no time left should just reset the house
            if (playerResourceTimeRemaining == 0){
                playerResourceTimeRemaining -= 1;
                return;
            }

            let roomIndex = getIndexFromCoords(playerX, playerY);
            let color = discoveredRooms[roomIndex];

            if (roomRemainingResources[roomIndex] <= 0){
                return;
            }

            if (roomColorNames[color] == "blue") {
                playerResourceBlue += 1;
                playerResourceTimeRemaining -= 1;
                roomRemainingResources[roomIndex] -= 1;
            } else if (roomColorNames[color] == "green") {
                playerResourceGreen += 1;
                playerResourceTimeRemaining -= 1;
                roomRemainingResources[roomIndex] -= 1;
            } else if (roomColorNames[color] == "red") {
                playerResourceRed += 1;
                playerResourceTimeRemaining -= 1;
                roomRemainingResources[roomIndex] -= 1;
            }

            return;
        }

        function getRandomRoomColor(){
            let randNum = Math.random(),
                s = 0,
                lastIndex = roomColorWeights.length - 1;
            
            for (var i = 0; i < lastIndex; ++i) {
                s += roomColorWeights[i];
                if (randNum < s) {
                    return roomColors[i];
                }
            }
            return roomColors[lastIndex];
        }

        function getIndexFromCoords(x, y){
            return (width * y) + x;
        }

        function getCoordsFromIndex(i){
            let y;
            if (i < width) {
                y = 0
                x = i;
            } else {
                y = Math.floor(i/width)
                x = i % (width * y);
            }
            return [x, y];
        } 

        function handleMovement(direction){
            if (animating) {
                return;
            }
            
            // Move player
            if (direction == "up"){
                playerY -= 1;
            } else if (direction == "right"){
                playerX += 1;
            } else if (direction == "down"){
                playerY += 1;
            } else if (direction == "left"){
                playerX -= 1;
            }
            
            // Check if room is new
            let color = discoveredRooms[getIndexFromCoords(playerX, playerY)];
            let newRoom = color == null;
            if (newRoom) {
                playerResourceTimeRemaining -= 2;
                color = getRandomRoomColor();
                let roomIndex = getIndexFromCoords(playerX, playerY);
                discoveredRooms[roomIndex] = color;
                if (roomColorNames[color] == "grey"){
                    roomRemainingResources[roomIndex] = 0;
                } else {
                    roomRemainingResources[roomIndex] = defaultRoomResources;
                }
            } else {
                if (features.exploredRoomsCostHalf) {
                    playerResourceTimeRemaining -= 1;
                } else {
                    playerResourceTimeRemaining -= 2;
                }
            }


            // Don't give resources automatically with actively gather on
            if (features.activelyGatherFromRooms != true){
                if (roomColorNames[color] == "blue") {
                    playerResourceBlue += 1;
                } else if (roomColorNames[color] == "green") {
                    playerResourceGreen += 1;
                } else if (roomColorNames[color] == "red") {
                    playerResourceRed += 1;
                }
            }

            checkCrafting();

            console.log("Player moved to: " + playerX + ", " + playerY + ". Color: " + color);
        }

        let resourcesForTorchSingleColor = 5;
        let resourcesForTorchMultiColor = 1;
        function checkCrafting() {
            if (
                playerResourceRed == resourcesForTorchMultiColor
                && playerResourceGreen == resourcesForTorchMultiColor
                && playerResourceBlue == resourcesForTorchMultiColor
            ){
                playerResourceBlue -= resourcesForTorchMultiColor;
                playerResourceGreen -= resourcesForTorchMultiColor;
                playerResourceRed -= resourcesForTorchMultiColor;
                playerResourceTorch += 1;
            }
            else if (playerResourceBlue >= resourcesForTorchSingleColor) {
                playerResourceBlue -= resourcesForTorchSingleColor;
                playerResourceTorch += 1;
            } else if (playerResourceRed >= resourcesForTorchSingleColor) {
                playerResourceRed -= resourcesForTorchSingleColor;
                playerResourceTorch += 1;
            } else if (playerResourceGreen >= resourcesForTorchSingleColor) {
                playerResourceGreen -= resourcesForTorchSingleColor;
                playerResourceTorch += 1;
            }

        }

        // Rendering
        const canvas = document.getElementById('game')
        var ctx = canvas.getContext('2d');

        function render(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < discoveredRooms.length; ++i) {
                let coords = getCoordsFromIndex(i);
                let x = coords[0];
                let y = coords[1];
                let color = discoveredRooms[i]
                if (color == null) {
                    continue;
                }
                drawRoom(x, y, i);
            }
            drawResources();
            drawPlayer();
        }

        function drawPlayer(){
            ctx.beginPath();
            ctx.lineWidth = "4";
            ctx.rect(
                playerX * roomSize + (playerX * 2),
                playerY * (roomSize) + (playerY * 2),
                roomSize + 2,
                roomSize + 2
            );
            ctx.stroke();
        }

        function drawRoom(x, y, index){
            let color = discoveredRooms[index];

            let topLeftX = 1 + (x * roomSize + (x * 2));
            let topLeftY = 1 + (y * (roomSize) + (y * 2));
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.fillRect(
                topLeftX,
                topLeftY,
                roomSize,
                roomSize
            );
            ctx.stroke();

            // Draw dots for remaining resources
            if (features.activelyGatherFromRooms){
                let topRightX = topLeftX + roomSize;
                let topRightY = topLeftY;
                ctx.fillStyle = "black";
                for (let i = 1; i <= roomRemainingResources[index]; ++i){
                    let offset = roomSize/4 * i;
                    ctx.fillRect(
                        topRightX - offset,
                        topRightY + 3,
                        roomSize/6,
                        roomSize/6
                    )
                }
            }
        }

        function drawResources(){
            ctx.font = '30px serif';
            ctx.fillText('Time Remaining: ' + playerResourceTimeRemaining, 4, roomSize);
            ctx.fillText('Red: ' + playerResourceRed, 4, roomSize * 2);
            ctx.fillText('Blue: ' + playerResourceBlue, 4, roomSize * 3);
            ctx.fillText('Green: ' + playerResourceGreen, 4, roomSize * 4);
            ctx.fillText('Yellow: ' + playerResourceYellow, 4, roomSize * 5);
            ctx.fillText('Torches: ' + playerResourceTorch, 4, roomSize * 6);
        }

        async function resetAnimation(){
            let lightWave = "#0099ff";
            let darkWave = "#003399";

            animating = true;

            ctx.fillStyle = lightWave;
            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (pinnedRooms[getIndexFromCoords(x, y)] != null){
                        continue
                    }
                    ctx.fillRect(
                        1 + (x * roomSize + (x * 2)),
                        1 + (y * (roomSize) + (y * 2)),
                        roomSize,
                        roomSize
                    )
                }
            }

            await sleep(500);

            ctx.fillStyle = darkWave;
            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (pinnedRooms[getIndexFromCoords(x, y)] != null){
                        continue
                    }
                    ctx.fillRect(
                        1 + (x  * roomSize + (x * 2)),
                        1 + (y * (roomSize) + (y * 2)),
                        roomSize,
                        roomSize
                    )
                }
            }

            await sleep(500);

            ctx.fillStyle = lightWave;
            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (pinnedRooms[getIndexFromCoords(x, y)] != null){
                        continue
                    }
                    ctx.fillRect(
                        1 + (x * roomSize + (x * 2)),
                        1 + (y * (roomSize) + (y * 2)),
                        roomSize,
                        roomSize
                    )
                }
            }

            await sleep(500);

            animating = false;

            render();
        }


        function sleep(ms){
            return new Promise(resolve => setTimeout(resolve, ms));
        }

    </script>
</html>
    